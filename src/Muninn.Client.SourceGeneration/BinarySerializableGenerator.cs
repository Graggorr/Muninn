using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Muninn.Client.SourceGeneration
{
    [Generator]
#pragma warning disable RS1036
    public sealed class BinarySerializableGenerator : IIncrementalGenerator
#pragma warning restore RS1036
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var candidates = context.SyntaxProvider
                .CreateSyntaxProvider(
                    static (syntax, _) => syntax is ClassDeclarationSyntax or StructDeclarationSyntax,
                    static (context, _) =>
                    {
                        var symbol = context.SemanticModel.GetDeclaredSymbol(context.Node);
                        
                        if (symbol is not INamedTypeSymbol type)
                        {
                            return null;
                        }

                        foreach (var interfaceType in type.AllInterfaces)
                        {
                            if (interfaceType.OriginalDefinition.ToDisplayString() == "IBinarySerializable<TSelf>")
                            {
                                return type;
                            }
                        }

                        return null;
                    }).Where(type => type is not null);

            context.RegisterSourceOutput(candidates, (spc, typeSymbol) =>
            {
                GenerateForType(spc, typeSymbol!);
            });
        }

        private void GenerateForType(SourceProductionContext context, INamedTypeSymbol typeSymbol)
        {
            var nameSpace = typeSymbol.ContainingNamespace.IsGlobalNamespace
                ? null
                : typeSymbol.ContainingNamespace.ToString();
            var typeName = typeSymbol.Name;

            var members = typeSymbol.GetMembers()
                .Where(member => member is IPropertySymbol { IsWriteOnly: false } or IFieldSymbol)
                .Where(member => !member.GetAttributes().Any(attribute => attribute.AttributeClass?.ToDisplayString() == nameof(MuninnIgnoreAttribute)))
                .ToList();

            var stringBuilder = new StringBuilder();
            stringBuilder.AppendLine("// <auto-generated />");
            stringBuilder.AppendLine("using System;");
            stringBuilder.AppendLine("using System.IO;");
            stringBuilder.AppendLine("using System.Text;");
            
            if (nameSpace is not null)
            {
                stringBuilder.AppendLine($"namespace {nameSpace}");
            }

            stringBuilder.AppendLine("{");
            stringBuilder.AppendLine($"    public partial class {typeName} : IBinarySerializable<{typeName}>");
            stringBuilder.AppendLine("    {");

            // Serialize
            stringBuilder.AppendLine($"        public byte[] Serialize(Encoding encoding)");
            stringBuilder.AppendLine("        {");
            stringBuilder.AppendLine("            using var stream = new MemoryStream();");
            stringBuilder.AppendLine("            using var writer = new BinaryWriter(stream, encoding, leaveOpen: true);");

            foreach (var member in members)
            {
                var type = member switch
                {
                    IPropertySymbol propertySymbol => propertySymbol.Type,
                    IFieldSymbol fieldSymbol => fieldSymbol.Type,
                    _ => null
                };
                
                if (type == null)
                {
                    continue;
                }
                
                var name = member.Name;
                stringBuilder.AppendLine(EmitWriteCode($"this.{name}", type, "            ", "encoding"));
            }

            stringBuilder.AppendLine("            return stream.ToArray();");
            stringBuilder.AppendLine("        }");

            // Deserialize
            stringBuilder.AppendLine($"        public {typeName} Deserialize(byte[] encodedValue, Encoding encoding)");
            stringBuilder.AppendLine("        {");
            stringBuilder.AppendLine("            using var stream = new MemoryStream(encodedValue);");
            stringBuilder.AppendLine("            using var reader = new BinaryReader(stream, encoding, leaveOpen: true);");
            stringBuilder.AppendLine($"            var result = new {typeName}();");

            foreach (var member in members)
            {
                var memberType = member switch
                {
                    IPropertySymbol propertySymbol => propertySymbol.Type,
                    IFieldSymbol fieldSymbol => fieldSymbol.Type,
                    _ => null
                };
                
                if (memberType is null)
                {
                    continue;
                }

                var name = member.Name;
                stringBuilder.AppendLine(EmitReadCode($"result.{name}", memberType, "            ", "encoding"));
            }

            stringBuilder.AppendLine("            return result;");
            stringBuilder.AppendLine("        }");
            stringBuilder.AppendLine("    }");
            stringBuilder.AppendLine("}");

            context.AddSource($"{typeName}.BinarySerializable.g.cs", stringBuilder.ToString());
        }

        private static string EmitWriteCode(string expression, ITypeSymbol type, string indent, string encodingVar)
        {
            if (type.SpecialType == SpecialType.System_Int32)
            {
                return $"{indent}writer.Write((byte)1);\n{indent}writer.Write({expression});";
            }

            if (type.SpecialType == SpecialType.System_Int64)
            {
                return $"{indent}writer.Write((byte)1);\n{indent}writer.Write({expression});";
            }

            if (type.SpecialType == SpecialType.System_Boolean)
            {
                return $"{indent}writer.Write((byte)1);\n{indent}writer.Write({expression});";
            }

            if (type.SpecialType == SpecialType.System_Double)
            {
                return $"{indent}writer.Write((byte)1);\n{indent}writer.Write({expression});";
            }

            if (type.SpecialType == SpecialType.System_Single)
            {
                return $"{indent}writer.Write((byte)1);\n{indent}writer.Write({expression});";
            }

            if (type.SpecialType == SpecialType.System_String)
            {
                return $@"{indent}if ({expression} == null) {{ writer.Write((byte)0); }} else {{
{indent}    writer.Write((byte)1);
{indent}    var bytes = {encodingVar}.GetBytes({expression});
{indent}    writer.Write(bytes.Length);
{indent}    writer.Write(bytes);
{indent}}}";
            }

            if (type.TypeKind == TypeKind.Enum)
            {
                return $"{indent}writer.Write((byte)1);\n{indent}writer.Write((int){expression});";
            }

            if (type is IArrayTypeSymbol arr)
            {
                var elementType = arr.ElementType;
                var inner = EmitWriteCode("item", elementType, indent + "        ", encodingVar);
                return $@"{indent}if ({expression} == null) {{ writer.Write(-1); }} else {{
{indent}    writer.Write({expression}.Length);
{indent}    foreach (var item in {expression})
{indent}    {{
{inner}
{indent}    }}
{indent}}}";
            }

            // Nested Muninn types (IBinarySerializable)
            return type.AllInterfaces.Any(i => i.OriginalDefinition.ToDisplayString() == "IBinarySerializable<TSelf>") 
                ? $"{indent}if ({expression} == null) writer.Write((byte)0); else {{ writer.Write((byte)1); var bytes = {expression}.Serialize({encodingVar}); writer.Write(bytes.Length); writer.Write(bytes); }}" 
                : $"{indent}// Unsupported type {type}";
        }

        private static string EmitReadCode(string target, ITypeSymbol type, string indent, string encodingVar)
        {
            if (type.SpecialType == SpecialType.System_Int32)
            {
                return $"{indent}if (reader.ReadByte() == 1) {target} = reader.ReadInt32();";
            }

            if (type.SpecialType == SpecialType.System_Int64)
            {
                return $"{indent}if (reader.ReadByte() == 1) {target} = reader.ReadInt64();";
            }

            if (type.SpecialType == SpecialType.System_Boolean)
            {
                return $"{indent}if (reader.ReadByte() == 1) {target} = reader.ReadBoolean();";
            }

            if (type.SpecialType == SpecialType.System_Double)
            {
                return $"{indent}if (reader.ReadByte() == 1) {target} = reader.ReadDouble();";
            }

            if (type.SpecialType == SpecialType.System_Single)
            {
                return $"{indent}if (reader.ReadByte() == 1) {target} = reader.ReadSingle();";
            }

            if (type.SpecialType == SpecialType.System_String)
            {
                return $@"{indent}if (reader.ReadByte() == 1) {{
{indent}    var length = reader.ReadInt32();
{indent}    var bytes = reader.ReadBytes(length);
{indent}    {target} = {encodingVar}.GetString(bytes);
{indent}}}";
            }

            if (type.TypeKind == TypeKind.Enum)
            {
                return $"{indent}if (reader.ReadByte() == 1) {target} = ({type.ToDisplayString()})reader.ReadInt32();";
            }

            if (type is IArrayTypeSymbol arr)
            {
                var elementType = arr.ElementType;
                var inner = EmitReadCode("arr[i]", elementType, indent + "        ", encodingVar);
                return $@"{indent}{{
{indent}    var length = reader.ReadInt32();
{indent}    if (length >= 0)
{indent}    {{
{indent}        var arr = new {elementType.ToDisplayString()}[length];
{indent}        for (var i = 0; i < length; i++)
{indent}        {{
{inner}
{indent}        }}
{indent}        {target} = arr;
{indent}    }}
{indent}}}";
            }
            if (type.AllInterfaces.Any(i => i.OriginalDefinition.ToDisplayString() == "IBinarySerializable<TSelf>"))
            {
                return $@"{indent}if (reader.ReadByte() == 1) {{
{indent}    var length = reader.ReadInt32();
{indent}    var bytes = reader.ReadBytes(length);
{indent}    {target} = new {type.ToDisplayString()}().Deserialize(bytes, {encodingVar});
{indent}}}";
            }

            return $"{indent}// Unsupported type {type}";
        }
    }
}
